/* glulxdump.c: Glulx game file decompiler.
    Designed by Andrew Plotkin <erkyrath@eblong.com>
    http://eblong.com/zarf/glulx/index.html
*/

/* This program is very much a cheap hack. It is *not* a generic,
   neutral decompiler for any Glulx file in existence. It assumes
   that the Glulx file was generated by Glulx-Inform. (This, of
   course, is how it is able to display objects; there *are* no
   objects in the Glulx spec, but this program understands the
   tables that Inform generates.)

   We are making the following Inform-specific assumptions:

   1. ROM contains only the header, functions, and strings, plus
   some padding. (In that order.)
   2. All the functions and strings are in ROM, not RAM.
   3. When disassembling the contents of a function, a C0, C1,
   E0, or E1 byte signals the start of a new object. (This will be
   true unless we add opcodes that start with those bytes. Which
   may happen someday. In fact, an opcode such as add (10) could
   be represented as C0000010, which would also violate this
   assumption, but Inform does not do this.)
   4. The first object begins at the start of RAM.
   5. Objects contain seven bytes worth of attributes. (This is
   currently hardwired in Inform, but can be changed easily by
   changing a #define and recompiling.)
   6. Dictionary words are nine characters long, and have three
   two-byte fields appended.
   7. Probably other stuff I forgot.

   This whole situation could be improved by adding a "layout
   convention" field, at the start of ROM, which could contain
   compiler-specific information about how to decompile the file.
   Maybe someday.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "glk.h"

#include "opcodes.h"

/* We define our own TRUE and FALSE and NULL, because ANSI
    is a strange world. */
#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif
#ifndef NULL
#define NULL 0
#endif

#define Read4(ptr)    \
  ( (glui32)(((unsigned char *)(ptr))[0] << 24)  \
  | (glui32)(((unsigned char *)(ptr))[1] << 16)  \
  | (glui32)(((unsigned char *)(ptr))[2] << 8)   \
  | (glui32)(((unsigned char *)(ptr))[3]))
#define Read2(ptr)    \
  ( (glui32)(((unsigned char *)(ptr))[0] << 8)  \
  | (glui32)(((unsigned char *)(ptr))[1]))
#define Read1(ptr)    \
  ((unsigned char)(((unsigned char *)(ptr))[0]))

#define Mem1(adr)  (Read1(memmap+(adr)))
#define Mem2(adr)  (Read2(memmap+(adr)))
#define Mem4(adr)  (Read4(memmap+(adr)))


typedef struct opcode_struct
{  
  const char *name; /* Lower case standard name */
  long code;        /* Opcode number */
  int flags;        /* Flags (see below) */
  int op_rules;     /* Any unusual operand rule applying (see below) */
  int no;           /* Number of operands */
} opcode_t;

#define St      1     /* Store (last operand is store-mode) */
#define Br      2     /* Branch (last operand is a label) */
#define Rf      4     /* "Return flag": execution never continues after this
                         opcode (e.g., is a return or unconditional jump) */

static const opcode_t opcodes_table[] = 
{
  /* This table must be sorted! */
  { "nop",            0x00,  0, 0, 0 },
  { "add",            0x10, St, 0, 3 },
  { "sub",            0x11, St, 0, 3 },
  { "mul",            0x12, St, 0, 3 },
  { "div",            0x13, St, 0, 3 },
  { "mod",            0x14, St, 0, 3 },
  { "neg",            0x15, St, 0, 2 },
  { "bitand",         0x18, St, 0, 3 },
  { "bitor",          0x19, St, 0, 3 },
  { "bitxor",         0x1A, St, 0, 3 },
  { "bitnot",         0x1B, St, 0, 2 },
  { "shiftl",         0x1C, St, 0, 3 },
  { "sshiftr",        0x1D, St, 0, 3 },
  { "ushiftr",        0x1E, St, 0, 3 },
  { "jump",           0x20, Br|Rf, 0, 1 },
  { "jz",             0x22, Br, 0, 2 },
  { "jnz",            0x23, Br, 0, 2 },
  { "jeq",            0x24, Br, 0, 3 },
  { "jne",            0x25, Br, 0, 3 },
  { "jlt",            0x26, Br, 0, 3 },
  { "jge",            0x27, Br, 0, 3 },
  { "jgt",            0x28, Br, 0, 3 },
  { "jle",            0x29, Br, 0, 3 },
  { "jltu",           0x2A, Br, 0, 3 },
  { "jgeu",           0x2B, Br, 0, 3 },
  { "jgtu",           0x2C, Br, 0, 3 },
  { "jleu",           0x2D, Br, 0, 3 },
  { "call",           0x30, St, 0, 3 },
  { "return",         0x31, Rf, 0, 1 },
  { "catch",          0x32, Br|St, 0, 2 },
  { "throw",          0x33, Rf, 0, 2 },
  { "tailcall",       0x34, Rf, 0, 2 },
  { "copy",           0x40, St, 0, 2 },
  { "copys",          0x41, St, 0, 2 },
  { "copyb",          0x42, St, 0, 2 },
  { "sexs",           0x44, St, 0, 2 },
  { "sexb",           0x45, St, 0, 2 },
  { "aload",          0x48, St, 0, 3 },
  { "aloads",         0x49, St, 0, 3 },
  { "aloadb",         0x4A, St, 0, 3 },
  { "aloadbit",       0x4B, St, 0, 3 },
  { "astore",         0x4C,  0, 0, 3 },
  { "astores",        0x4D,  0, 0, 3 },
  { "astoreb",        0x4E,  0, 0, 3 },
  { "astorebit",      0x4F,  0, 0, 3 },
  { "stkcount",       0x50, St, 0, 1 },
  { "stkpeek",        0x51, St, 0, 2 },
  { "stkswap",        0x52,  0, 0, 0 },
  { "stkroll",        0x53,  0, 0, 2 },
  { "stkcopy",        0x54,  0, 0, 1 },
  { "streamchar",     0x70,  0, 0, 1 },
  { "streamnum",      0x71,  0, 0, 1 },
  { "streamstr",      0x72,  0, 0, 1 },
  { "streamunichar",  0x73,  0, 0, 1 },
  { "gestalt",        0x0100, St, 0, 3 },
  { "debugtrap",      0x0101,  0, 0, 1 },
  { "getmemsize",     0x0102, St, 0, 1 },
  { "setmemsize",     0x0103, St, 0, 2 },
  { "jumpabs",        0x0104, Rf, 0, 1 },
  { "random",         0x0110, St, 0, 2 },
  { "setrandom",      0x0111,  0, 0, 1 },
  { "quit",           0x0120,  0, 0, 0 },
  { "verify",         0x0121, St, 0, 1 },
  { "restart",        0x0122,  0, 0, 0 },
  { "save",           0x0123, St, 0, 2 },
  { "restore",        0x0124, St, 0, 2 },
  { "saveundo",       0x0125, St, 0, 1 },
  { "restoreundo",    0x0126, St, 0, 1 },
  { "protect",        0x0127,  0, 0, 2 },
  { "glk",            0x0130, St, 0, 3 },
  { "getstringtbl",   0x0140, St, 0, 1 },
  { "setstringtbl",   0x0141,  0, 0, 1 },
  { "getiosys",       0x0148, St, 0, 2 },
  { "setiosys",       0x0149,  0, 0, 2 },
  { "callf",          0x0160, St, 0, 2 },
  { "callfi",         0x0161, St, 0, 3 },
  { "callfii",        0x0162, St, 0, 4 },
  { "callfiii",       0x0163, St, 0, 5 },
  { "mzero",          0x0170,  0, 0, 2 },
  { "mcopy",          0x0171,  0, 0, 3 },
  { "malloc",         0x0178, St, 0, 2 },
  { "mfree",          0x0179,  0, 0, 1 },
  { "accelfunc",      0x0180,  0, 0, 2 },
  { "accelparam",     0x0181,  0, 0, 2 },
};

static int read_header(FILE *fl);
static const opcode_t *findopcode(int opnum);
void print_string(glui32 pos);
void print_proptable(glui32 pos);
void dump_ram(void);
void dump_objs(void);
void dump_action_table(void);
void dump_dict_table(void);
void dump_grammar_table(void);

int dumpfuncs = FALSE;
int dumpstrings = FALSE;
int dumpobjs = FALSE;
int dumpheader = FALSE;
int dumpactiontbl = FALSE;
int dumpdicttbl = FALSE;
int dumpgrammartbl = FALSE;
glui32 posactiontbl = 0;
glui32 posdicttbl = 0;
glui32 posgrammartbl = 0;
unsigned char *memmap = NULL;

glui32 version;
glui32 ramstart;
glui32 endgamefile;
glui32 endmem;
glui32 stacksize;
glui32 startfuncaddr;
glui32 stringtable;
glui32 checksum;

int main(int argc, char *argv[])
{
  FILE *fl;
  int ix, jx;
  int ch;
  int startpos;
  glui32 val;
  char *filename = NULL;

  if (argc < 2) {
    printf("Usage: glulxdump file\n");
    exit(1);
  }

  for (ix=1; ix<argc; ix++) {
    if (!strcmp(argv[ix], "-f"))
      dumpfuncs = TRUE;
    else if (!strcmp(argv[ix], "-s"))
      dumpstrings = TRUE;
    else if (!strcmp(argv[ix], "-o"))
      dumpobjs = TRUE;
    else if (!strcmp(argv[ix], "-h"))
      dumpheader = TRUE;
    else if (!strcmp(argv[ix], "-a")) {
      ix++;
      if (ix >= argc || (val = strtol(argv[ix], NULL, 16)) == 0) {
        printf("-a must be followed by address.\n");
        exit(1);
      }
      posactiontbl = val;
      dumpactiontbl = TRUE;
    }
    else if (!strcmp(argv[ix], "-d")) {
      ix++;
      if (ix >= argc || (val = strtol(argv[ix], NULL, 16)) == 0) {
        printf("-d must be followed by address.\n");
        exit(1);
      }
      posdicttbl = val;
      dumpdicttbl = TRUE;
    }
    else if (!strcmp(argv[ix], "-g")) {
      ix++;
      if (ix >= argc || (val = strtol(argv[ix], NULL, 16)) == 0) {
        printf("-g must be followed by address.\n");
        exit(1);
      }
      posgrammartbl = val;
      dumpgrammartbl = TRUE;
    }
    else
      filename = argv[ix];
  }

  if (!filename) {
    printf("No file given\n");
    exit(1);
  }

  if (!dumpfuncs && !dumpstrings && !dumpobjs && !dumpheader 
    && !dumpactiontbl && !dumpdicttbl && !dumpgrammartbl) {
    dumpfuncs = TRUE;
    dumpstrings = TRUE;
    dumpobjs = TRUE;
    dumpheader = TRUE;
  }

  fl = fopen(filename, "r");
  if (!fl) {
    perror("unable to open file");
    exit(1);
  }

  ix = read_header(fl);
  if (!ix) {
    fclose(fl);
    exit(1);
  }

  memmap = (unsigned char *)malloc(endgamefile);
  rewind(fl);
  ix = fread(memmap, 1, endgamefile, fl);
  if (ix != endgamefile) {
    printf("File too short.\n");
    fclose(fl);
    exit(1);
  }

  fclose(fl);
  fl = NULL;

  if (dumpheader) {
    printf("Version:   %08lx\n", (long)version);
    printf("RAMSTART:  %08lx\n", (long)ramstart);
    printf("ENDGAME:   %08lx\n", (long)endgamefile);
    printf("ENDMEM:    %08lx\n", (long)endmem);
    printf("STACKSIZE: %08lx\n", (long)stacksize);
    printf("StartFunc: %08lx\n", (long)startfuncaddr);
    printf("StringTbl: %08lx\n", (long)stringtable);
    printf("CheckSum:  %08lx\n", (long)checksum);
  }

  if (dumpstrings || dumpfuncs)
    dump_ram();
  if (dumpobjs)
    dump_objs();

  if (dumpactiontbl) 
    dump_action_table();
  if (dumpdicttbl) 
    dump_dict_table();
  if (dumpgrammartbl) 
    dump_grammar_table();

  exit(0);
}

static int read_header(FILE *fl)
{
  unsigned char buf[4 * 9];
  int res;

  /* Read in all the size constants from the game file header. */

  res = fread(buf, 1, 4 * 9, fl);
  if (res != 4 * 9) {
    printf("This file is too short.\n");
    return FALSE;
  }
  
  if (buf[0] != 'G' || buf[1] != 'l' || buf[2] != 'u' || buf[3] != 'l') {
    printf("This does not appear to be a Glulx file.\n");
    return FALSE;
  }

  version = Read4(buf+4);
  ramstart = Read4(buf+8);
  endgamefile = Read4(buf+12);
  endmem = Read4(buf+16);
  stacksize = Read4(buf+20);
  startfuncaddr = Read4(buf+24);
  stringtable = Read4(buf+28);
  checksum = Read4(buf+32);

  return TRUE;
}

void dump_ram()
{
  glui32 pos, startpos;
  unsigned char ch;
  int jx;

  pos = 4 * (9+5);

  while (pos < ramstart) {
    startpos = pos;
    ch = Mem1(pos);
    
    if (ch == 0) {
      /* skip padding */
      pos++;
    }
    else if (ch == 0xE0) {
      if (dumpstrings) {
        printf("String (%08lx): ", (long)startpos);
        pos++;
        while (1) {
          ch = Mem1(pos);
          pos++;
          if (ch == '\0')
            break;
          putchar(ch);
        }
        printf("\n");
      }
      else {
        while (1) {
          ch = Mem1(pos);
          pos++;
          if (ch == '\0')
            break;
        }
      }
    }
    else if (ch == 0xC0 || ch == 0xC1) {
      int loctype, locnum;
      int opcode;
      const opcode_t *opco;
      glui32 exstart;
      int opmodes[16];

      printf("Function (%08lx), ", (long)startpos);
      if (ch == 0xC0)
        printf("stack-called:");
      else
        printf("locals-called:");

      pos++;

      while (1) {
        loctype = Mem1(pos);
        pos++;
        locnum = Mem1(pos);
        pos++;
        if (loctype == 0)
          break;
        printf(" %d %d-byte local%s,", locnum, loctype,
          ((locnum == 1) ? "" : "s"));
      }
      printf("\n");

      ch = Mem1(pos);
      pos++;
      exstart = pos;

      while (ch != 0xC0 && ch != 0xC1 && ch != 0xE0) {
        /* wrong, but the hell with it */

        /* Get the opcode */
        if ((ch & 0x80) == 0) {
          opcode = ch;
        }
        else if ((ch & 0x40) == 0) {
          opcode = (ch & 0x7F);
          ch = Mem1(pos); pos++;
          opcode = (opcode << 8) | ch;
        }
        else {
          opcode = (ch & 0x3F);
          ch = Mem1(pos); pos++;
          opcode = (opcode << 8) | ch;
          ch = Mem1(pos); pos++;
          opcode = (opcode << 8) | ch;
          ch = Mem1(pos); pos++;
          opcode = (opcode << 8) | ch;
        }
        opco = findopcode(opcode);
        printf("  %08lx: %12s ", (long)(pos-exstart), opco->name);

        for (jx=0; jx<opco->no; jx+=2) {
          ch = Mem1(pos); pos++;
          opmodes[jx+0] = (ch & 0x0F);
          opmodes[jx+1] = ((ch >> 4) & 0x0F);
        }

        for (jx=0; jx<opco->no; jx++) {
          int val = 0;
          printf(" ");
          switch (opmodes[jx]) {
          case 0:
            printf("zero");
            break;
          case 8:
            printf("stackptr");
            break;
          case 1:
          case 5:
          case 9:
          case 13:
            if ((opmodes[jx] & 0x0C) == 4)
              printf("*");
            else if ((opmodes[jx] & 0x0C) == 8)
              printf("Fr:");
            else if ((opmodes[jx] & 0x0C) == 12)
              printf("*R:");
            ch = Mem1(pos); pos++;
            val = ch;
            if (val & 0x80)
              val |= 0xFFFFFF00;
            printf("%02x", val & 0xFF);
            break;
          case 2:
          case 6:
          case 10:
          case 14:
            if ((opmodes[jx] & 0x0C) == 4)
              printf("*");
            else if ((opmodes[jx] & 0x0C) == 8)
              printf("Fr:");
            else if ((opmodes[jx] & 0x0C) == 12)
              printf("*R:");
            ch = Mem1(pos); pos++;
            val = ch;
            if (val & 0x80)
              val |= 0xFFFFFF00;
            ch = Mem1(pos); pos++;
            val = (val << 8) | ch;
            printf("%04x", val & 0xFFFF);
            break;
          case 3:
          case 7:
          case 11:
          case 15:
            if ((opmodes[jx] & 0x0C) == 4)
              printf("*");
            else if ((opmodes[jx] & 0x0C) == 8)
              printf("Fr:");
            else if ((opmodes[jx] & 0x0C) == 12)
              printf("*R:");
            ch = Mem1(pos); pos++;
            val = ch;
            ch = Mem1(pos); pos++;
            val = (val << 8) | ch;
            ch = Mem1(pos); pos++;
            val = (val << 8) | ch;
            ch = Mem1(pos); pos++;
            val = (val << 8) | ch;
            printf("%08x", val);
            break;
          }
          if ((opco->flags & Br) && (jx == opco->no-1)) {
            if (val == 0) {
              printf(" (rfalse)");
            }
            else if (val == 1) {
              printf(" (rtrue)");
            }
            else {
              printf(" (%08lx)", (long)((pos-exstart)+val-2+1));
            }
          }
        }
        printf("\n");
        
        ch = Mem1(pos); pos++;
      }

      pos--;
    }
    else {
      printf("Unknown thing.\n");
      pos++;
    }
  }
}

static int compare_opcode_t(const void *a, const void *b)
{
  const opcode_t *opa = (const opcode_t *)a;
  const opcode_t *opb = (const opcode_t *)b;
  return opa->code - opb->code;
}

static const opcode_t *findopcode(int opnum)
{
  const opcode_t *op;
  opcode_t key;

  key.code = opnum;
  op = bsearch(&key, &opcodes_table,
               sizeof(opcodes_table) / sizeof(opcodes_table[0]),
               sizeof(opcodes_table[0]),
               &compare_opcode_t);
  if (!op) {
    printf("Unknown opcode %02x\n", opnum);
    op = &opcodes_table[0];
  }
  return op;
}

void dump_objs()
{
  glui32 startpos, pos, nextstartpos, proptablepos;
  unsigned char ch;
  int ix, jx;

  startpos = ramstart;
  while (startpos) {

    ch = Mem1(startpos);
    if (ch != 0x70) {
      printf("Non-object in object list (%08lx)\n", (long)startpos);
      return;
    }
    pos = startpos+1;

    printf("Object (%08lx):\n", (long)startpos);
    printf("    attrs:");
    for (ix=0; ix<7; ix++) {
      ch = Mem1(pos); pos++; 
      printf(" ");
      for (jx=0; jx<8; jx++) {
        printf("%c", (ch&1) ? '1' : '0');
        ch >>= 1;
      }
    }
    printf("\n");

    for (ix=0; ix<6; ix++) {
      static char *labellist[6] = {
        "next", "name", "props", "parent", "sibling", "child"
      };
      long val;
      ch = Mem1(pos); pos++;
      val = ch;
      ch = Mem1(pos); pos++;
      val = (val << 8) | ch;
      ch = Mem1(pos); pos++;
      val = (val << 8) | ch;
      ch = Mem1(pos); pos++;
      val = (val << 8) | ch;
      printf("  %7s: ", labellist[ix]);
      printf("%08lx", val);
      switch (ix) {
      case 0:
        nextstartpos = val;
        break;
      case 1:
        printf("  ");
        print_string(val);
        break;
      case 2:
        proptablepos = val;
        break;
      }
      printf("\n");
    }

    print_proptable(proptablepos);
    
    startpos = nextstartpos;
    printf("\n");
  }
}

void print_string(glui32 pos)
{
  unsigned char ch;
  ch = Mem1(pos);
  if (ch != 0xE0) {
    printf("<nonstring %08lx>", (long)pos);
    return;
  }
  pos++;
  while (1) {
    ch = Mem1(pos);
    pos++;
    if (ch == '\0')
      return;
    putchar(ch);
  }
}

void print_proptable(glui32 pos)
{
  unsigned char ch;
  int ix, jx;
  int numprops;
  
  numprops = Mem4(pos);
  pos += 4;

  printf("%d properties:\n", numprops);

  for (ix=0; ix<numprops; ix++) {
    int propnum, proplen, propflags;
    glui32 addr;
    propnum = Mem2(pos);
    pos += 2;
    proplen = Mem2(pos);
    pos += 2;
    addr = Mem4(pos);
    pos += 4;
    propflags = Mem2(pos);
    pos += 2;
    printf("  num=%d, len=%d, flags=%d, addr=%08lx\n",
      propnum, proplen, propflags, (long)addr);
    printf("  :");
    for (jx=0; jx<proplen; jx++) {
      glsi32 val = Mem4(addr);
      addr += 4;
      printf(" %lx", (long)val);
    }
    printf("\n");
  }
}

void dump_action_table()
{
  glui32 lx, len, val;

  len = Mem4(posactiontbl);

  printf("Action table at %08lx: %ld entries\n", (long)posactiontbl, (long)len);
  for (lx=0; lx<len; lx++) {
    val = Mem4(posactiontbl + 4 + lx*4);
    printf("%ld: %08lx\n", (long)lx, (long)val);
  }
}

void dump_dict_table()
{
  glui32 lx, len, val, addr;
  char ch;
  int ix;

  len = Mem4(posdicttbl);

  printf("Dictionary table at %08lx: %ld entries\n", (long)posdicttbl, (long)len);
  for (lx=0; lx<len; lx++) {
    addr = posdicttbl + 4 + lx*16;
    printf("%08lx: ", (long)addr);
    for (ix=0; ix<9; ix++) {
      ch = Mem1(addr+1+ix);
      if (ch == '\0')
        ch = ' ';
      printf("%c", ch);
    }
    printf(" : ");
    val = Mem2(addr+10);
    printf("flags=%04lx", (long)val);
    val = Mem2(addr+12);
    printf(", verbnum=%04lx", (long)val);
    val = Mem2(addr+14);
    printf(", filler=%lx", (long)val);
    printf("\n");
  }
}

void dump_grammar_table()
{
  glui32 lx, len, val, addr;
  int numlines;
  char ch;
  int ix, jx;

  len = Mem4(posgrammartbl);

  printf("Grammar table at %08lx: %ld entries\n", (long)posgrammartbl, (long)len);

  for (lx=0; lx<len; lx++) {
    addr = posgrammartbl + 4 + lx*4;
    addr = Mem4(addr);
    printf("%03ld: %08lx: ", (long)lx, (long)addr);
    numlines = Mem1(addr);
    addr++;
    printf("%d lines:\n", numlines);
    for (jx=0; jx<numlines; jx++) {
      glui32 action, toktype, tokdata;
      action = Mem2(addr);
      addr += 2;
      val = Mem1(addr);
      addr++;
      printf("    ac %04lx; fl %02lx :", (long)action, (long)val);
      while (1) {
        toktype = Mem1(addr);
        addr++;
        if (toktype == 15) {
          printf(" .\n");
          break;
        }
        tokdata = Mem4(addr);
        addr += 4;
        printf(" %02lx(%04lx)", (long)toktype, (long)tokdata);
      }
    }
  }
}
